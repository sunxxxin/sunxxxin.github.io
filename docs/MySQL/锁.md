# 锁

## MySQL里有哪些锁

MySQL里根据加锁的范围，分为全局锁，表级锁，行锁

### 全局锁

要使用全局锁，需要在MySQL中执行命令

flush tables with read lock

执行后其他线程对数据的增删改会被阻塞

对表结构的增删改会被阻塞

释放全局锁用如下命令

unlock tables

全局锁主要应用于**全局逻辑备份**

因为开全局锁期间会导致数据都是只读的，会导致业务阻塞，所以可以先开启事务，然后在备份数据库，因为有mvcc支持备份数据库期间也可以对数据修改

### 表级锁

表级锁主要有

表锁

元数据锁（MDL）

意向锁

AUTO_INC锁

#### 表锁

表锁分为读锁（表级别的共享锁）和写锁（标记别的独占锁）

```
lock tables 表名 read;

lock tables 表名 write;
//解锁操作
unlock tables  
```

表锁不仅会限制其他线程的读写操作，也会限制本线程接下来的读写操作语句

#### 元数据锁（MDL）

不需要显示的使用MDL在对数据库表进行操作的时候，会自动给这个表加上MDL

对一个表进行CRUD（创建（Create）、读取（Read）、更新（Update）和删除（Delete））加的是MDL读锁；

对一个表结构做变更操作的时候，加的是MDL写锁；

当有线程在执行select的时候如果有其他线程要修改表的结构（申请MDL写锁）会被阻塞，知道select完成（释放读锁）

反之亦然

##### MDL什么时候会释放呢？

只有在事务提交的时候才会释放锁；

这样就会导致一个问题

假设一个事务a  select了一下但是没有提交时候这时候表是加的MDL读锁

这时事务b对这个表也select了 并没有堵塞

这时事务c对这个表进行写操作，这时申请写锁，但是表现在加着读锁，所以c事务阻塞等待，这时候往后所有事务对这个表的所有操作都不能支持了

因为申请MDL锁的操作会形成一个队列，队列中写锁获取的优先级高于读锁，一旦出现MDL写锁会阻塞后续所有的crud操作

一般发生这种情况就要先看看MySQL中是否有长事务对表加上了读锁，可以考虑杀死这个事务，然后再做表结构变更

#### 意向锁

在使用inondb引擎的表里对某些记录加上共享锁之前，需要在表级别加上一个意向共享锁

在使用innodb引擎的表里对某些记录加上独占锁之前，需要现在表级别上加上一个意向独占锁

也就是，当执行插入，更新，删除操作，需要对表加上意向独占锁，然后对该记录加独占锁，普通的select 是不会加行级锁的，他是使用MVCC实现一致性读的，无锁，不过硬要加也能加

```mysql
//先在表上加意向共享锁，然后对读取的记录加共享锁
select ...lock in share mode;
//现在表上加意向独占锁，然后对读取的记录加独占锁
select ...for update；
```

意向共享锁和意向读写锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突

如果没有意向锁，那么加独占表锁的时候，就要遍历表里的所有记录，查看是否有记录存在独占锁，这样效率很慢

如果有了意向锁，由于在对记录加独占锁前，会加上表级别的意向独占锁，那么在加独占表锁的时候，直接查该表里是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里面的元素

所以，意向锁的目的是为了快速判断表里是否有记录被加锁

#### AUTO-INC锁

表里的主键通常会设置为自增的，这是通过对主键字段声明auto_increment属性实现的。

之后插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过AUTO-ANC锁实现的

在插入一个数据的时候，会增加一个表级别的AUTO-INC锁，然后为auto_increment修饰的字段赋值递增的值，等插入语句执行完成后，才会把AUTO-INC锁释放掉

那么，一个事务在持有AUTO-INC锁的过程中，其他事务如果要向该表插入语句都会被阻塞，从而保证插入数据时，被AUTO_INCREMENT修饰的字段都是连续递增的

但是，AUTO-INC锁对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞

 因此，在MySQL5.1.22版本开始，innodb存储引擎提供了一种轻量级的锁，来实现自增。

一样也是在插入数据的时候，会为被AUTO-INCREMENT修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，然后把这个轻量级锁释放了，而不需要等待整个插入语句执行完成后才释放锁

innodb存储引擎提供了一个系统变量，innodb_autoinc_lock_mode 来控制选择使用AUTO-INC，还是使用轻量级的锁

当innodb_autoinc_lock_mode=0,就采用AUTO-INC锁，语句执行结束后才释放锁；

当innodb_autoinc_lock_mode=2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放

当innodb_autoinc_lock_mode=2是性能最高的时候，但是搭配binlog日志格式是statement一起使用的时候，在主从复制场景会发生数据不一致的问题

假设两个事务a，b同时往一个表里插入数据，事务a先插自增主键为2 这时候b插主键我3，这时候a错误回滚了，但是b还是3   这时候从库读取binlog读取的是b的插入语句这时候从库b是2

## 行级锁

innodb 引擎是支持行级锁的，而MyISAM引擎并不支持行级锁

前面也提到，普通的select语句是不会对记录加锁的，因为它属于快照读，如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为锁定读

```
//对读记录加共享锁
select...lock in share mode;

//对读取的记录加独占锁
select ...for update;

```

上述的两条语句必须在一个事务中，因为当事务提交了，锁就会释放，所以在使用这两条语句的时候，要加上begin，start transaction 或者set autocommit=0

共享锁（s锁）满足读读共享，读写互斥，独占锁（x锁）满足写写互斥，读写互斥

行级锁的类型主要有三类：

record lock，记录锁，也就是仅仅把一条记录锁上；

gap lock ，间隙锁，锁定一个范围，但是不包含记录本身；

next-key lock：record lock +gap lock 的组合，锁定一个范围，并且锁定记录本身

#### record lock

record lock 称为记录锁，锁住的是一条记录。而且记录锁有s锁和x锁之分的

当一个事务对一条记录加了s型纪录锁后，其他事务也可以继续对该记录加s型纪录锁（s锁与s锁兼容），但是不可以对该记录加x型记录锁（s型与x型不兼容）；

当一个事务对一条记录加了x型记录锁后，其他事务既不可以对该记录加s型记录锁（s锁与x锁不兼容），也不可以对该记录加x型纪录锁（x型与x锁不兼容）

举例

```msyql
begin;
select  * from student where id =1 for unpdate;
```

这样就是对id=1的记录加上x型锁，此时别的事务都无法对这条记录进行修改了

当事务执行 commit后，事务过程中生成的锁都会被释放

#### Gap lock

gao lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象

假设，表中有一个范围id为（3，5）间隙锁，那么其他事务就无法插入id=4这条记录了，这样就有效的防止幻读现象的发生

间隙锁虽然存在x型间隙锁和s型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的

#### Next-Key Lock

next-key lock称为临键锁，是record lock+gap lock 的组合，锁定一个范围，并且锁定记录本身。

假设表中有一个范围id为（3，5]的next-key lock，那么其他事务既不能插入id=4记录也不能修改id=5这条记录

所以，next-key lock既能保护该记录，又能防止其他事务将新纪录插入到被保护记录前面的间隙中

next-key lock 是包含间隙+记录锁的，如果一个事务获取了x型的next-key lock，那么另一个事务在获取相同范围x型的next-key lock时，是会被阻塞的

比如，一个事务持有了范围为（1，10]的x型的next-key lock，那么另一个事务在获取相同范围的x型的next-key lock时，就会被阻塞

虽然相同范围的间隙锁是多个事务相互兼容的，但是对于记录锁，我们要考虑x型与s型，x型的纪录锁与x型的纪录锁是冲突的

#### 插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock也包含间隙锁）

如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新纪录，但是现在处于等待状态

举个例子，假设事务a已经对表加了一个范围id为（3，5）间隙锁。

当事务a还没提交的时候，事务b向该表插入一条id=4的新纪录，这时会判断到插入的位置已经被事务a加了间隙锁，于是事务b会生成一个插入意向锁，然后将锁的状态设置为等待状态（MySQL加锁时，是先生成锁结构，然后设置锁的状态，如果锁的状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁的状态为正常状态时，才代表事务成功获取到了锁），此时事务b就会发生阻塞，直到事务a提交了事务

插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁

如果说间隙锁锁住的是一个区间，那么插入意向锁锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁

插入意向锁与间隙锁的另一个非常重要的差别是：尽管插入意向锁也属于间隙锁，但是两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不再间隙区间内则是可以的）