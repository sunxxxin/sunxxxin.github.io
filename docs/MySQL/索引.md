# 索引

## 索引的概念

索引就相当于数据的目录，方便我们更快的查找到数据

## 索引的分类

按数据结构分类：b+树索引，hash索引（InnDB不支持），full_text索引（全文索引）

按物理储存分类：聚簇索引（主键索引），二级索引（辅助索引）

按字段分类 ：主键索引，唯一索引，前缀索引，普通索引

按字段个数分类：单列索引，联合索引

### 按数据结构分类

#### B+树索引

b+树是一种多叉树，只有叶子节点放数据，非叶子节点只放索引值，

并且上一层的所有索引值都会在下一层出现，叶子节点包含了所有的索引值，

每一个叶子节点都有两个指针分别指向上一个叶子节点和下一个叶子节点

下图（双向链表省略）



![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdgV8QoMTlAsFLK9yrPWQiapWzXLEtpJD3IsGAXyTsJQvXibTAnIYHKkIekK7licSTVftymQZ2gs4kEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在创建表的时候，InnoDB引擎会根据不同的场景选择不同的列作为索引：

如果有主键，默认会使用主键作为聚簇索引的索引键（key）

如果没有主键，默认会选择第一个不包含null值的唯一列作为聚簇索引的索引键（key）

如果两个都没有，innodb将自动生成一个隐式自增id列作为聚簇索引的索引键（key）

聚簇索引和其他二级索引的区别是，完整数据都存在聚簇索引上，其他的二级索引存的是主键值，如果想拿到完整的数据还要回到聚簇索引再查一下也就是回表操作

#### 为什么MySQL InnDB选择b+树作为数据索引？

**二叉查找树**

二叉查找树，数据量太大的话的高度就太高了，导致每次查询数据的时候磁盘io次数太多影响查询性能，并且二叉树有时候还会退化为链表使得时间复杂度从o(logn)降低为o(n),并且不能范围查找

**平衡二叉树**

通过在原来二叉树的基础上增加约束条件（每个节点的左子树和右子树的高度差不能超过1）解决了二叉树会退化为链表的情况，使得时间复杂度一直为o（logn）

类似的红黑树也是通过增加约束条件使之自平衡

但是都有一个通病就是，都会随着插入的元素增多，导致树的高度变高，这就意味着磁盘i/o的操作次数多，会影响整体数据查询的效率

**B树**

b树在自平衡二叉树上升级，不再限制节点数量，这样使树的层数下减少了i/o次数

但是b树每个节点都包括了索引值和记录，假如记录大小远大于索引值大小的时候用户就需要花费更多的磁盘i/o来读取到有用的索引数据

当我们在查询最底层每个节点的记录过程冲，查找过程中遍历过的节点数据也会被加载到内存，这部分数据是没用的不仅增加i/o操作还浪费内存资源

并且b数来坐范围查询的话需要中序遍历会涉及多个节点的磁盘i/o问题从而导致整体速度下降

### 按字段个数分类

#### 联合索引

![联合索引](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png)

例如创建（a,b,c）联合索引

会先按a排序，a相同排b，b相同排c

联合索引的最左匹配原则，在遇到范围查找（><）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引（对应>=,<=,between,like,前缀匹配的范围查询,并不会停止匹配）

#### 索引下推

mysql5.6引入索引下推优化,可以在联合索引遍历过程中,对联合索引中包含的字段先做判断直接过滤掉不满足条件的记录,减少回表次数.

例如对应联合索引(a,b)

执行select * from table where a>1 and b=2语句的时候,a用完索引的时候直接判断一下b,不用再一个个的数据回到聚簇索引里查,减少了回表的次数

### 什么时候需要/不需要创建索引?

索引好处是提高查询速度,但是索引也有缺点,比如:

需要占用物理空间

创建索引和维护索引要耗费时间

会降低表的增删改效率,因为每次增删改索引,B+树为了维护索引有序性,都需要进行动态维护

**什么时候适用索引?**

字段有唯一性限制的;

经常用于where查询条件的字段;

经常用于group by 和 order by 的字段,这样在查询的时候就不需要再去做一次排序了

**什么时候不适用于创建索引?**

含有大量重复的数据不需要建索引

表数据少的时候

经常更新的字段不用创建索引

### 索引的优化方法

  **前缀索引优化**

使用某个字段中的前几个字符建立索引

这样可以增加一个索引页中存储索引的索引值,提高查询速度

但是order by 就无法使用索引了,无法把前缀索引用作覆盖索引

**覆盖索引优化**

就是创建索引的时候二级索引创成联合索引包含要查的数据,这样就避免回表操作

**主键索引最好是自增的**

这样每次插入一条新纪录的时候都是追加操作,不需要重新移动数据

**索引最好设置为非空**

1.如果存在空的时候优化器再做索引选择的时候会更加复杂,更加难以优化

2.null是一个没有实际意义的值,但是他也会占用物理空间,所有会带来存储空间的问题











