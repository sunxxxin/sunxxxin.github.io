# Redis常见数据类型和应用场景

Redis中常见的数据类型有五种：**String（字符串），Hash（哈希），List（列表），Set（集合），Zset（有序集合）。**

随着Redis版本的更新，后面又支持了四种数据类型：**BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。**

## String

### 介绍

String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串，也可以是数字(整数或浮点数)，value 最多可以容纳的数据长度是512M。

### 内部实现

String类型的底层的数据结构实现主要是int和SDS（简单动态字符串）。

SDS相比于C的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据。**因为SDS使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[]数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)。**因为C语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n);而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

**字符串的内部编码（encoding）有三种：int、raw和embstr（raw和embstr为SDS（简单动态字符串））。**

如果一个字符串对象保存的是整数值，并且这个整数值可以用 long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面(将 void*转换成 long)，并将字符串对象的编码设置为int 。

如果字符串对象保存的是一个字符串则有两种情况：

1. 字符串长度小于等于32字节（redis2.+版本）
   字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为 embstr，embstr 编码是专门用于保存短字符串的一种优化编码方式。
2. 字符串长度大于32字节（redis2.+版本）
   那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串，并将对象的编码设置为 raw。

可以看到 embstr 和 raw 编码都会使用 SDS 来保存值，但**不同之处在于** embstr 会通过**一次内存分配**函数来分配一块连续的内存空间来保存 redisobiect 和 SDS ，而 raw 编码会通过调用**两次内存分配**函数来分别分配两块空间来保存 redisobject 和 SDS 。Redis这样做会有很多好处:

- embstr 编码将创建字符串对象所需的内存分配次数从 raw编码的两次降低为一次;
- 释放 embstr 编码的字符串对象同样只需要调用一次内存释放函数;
- 因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。

但是 embstr 也有缺点的:

- 如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，所以**embstr编码的字符串对象实际上是只读的**，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令(例如append)时，程序会先将**对象的编码从embstr转换成raw**，然后再执行修改命令。

### 常用操作

- set：设置字符串
- get：读取字符串
- incr：自增（1）
- decr：自减（1）
- exists：判断某个key是否存在
- strlen：返回字符串长度
- del：删除key
- expire：设置过期时间
- ttl：查看剩余过期时间
- set nx：不存在就插入（成功返回1，失败返回0）
- mset：批量设置字符串
- mget：批量读取字符串

### 应用场景

#### 缓存对象

使用 String 来缓存对象有两种方式:

- 直接缓存整个对象的JSON，命令例子:SET user:1'{"name":"隔壁老王"，“age”:38}'

- 采用将 key 进行分离为 user:ID:属性，采用 MSET存储，用 MGET获取各属性值，

  命令例子:  

  MSET  user:1:name "隔壁老王头" user:1:age 38 

  ​			 user:2:name "楼下老吴头" user:2:age 40 

#### 常规计数

因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。

#### 分布式锁

SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁

- 如果 key 不存在，则显示插入成功，可以用来表示加锁成功;
- 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。

#### 共享session信息

通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。

例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。

因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。

## List

### 介绍

List列表是最简单的字符串列表，按照插入顺序排序，可以从头部或尾部向List列表添加元素。

列表的最大长度为2^32 - 1，即每个列表支持超过40亿个元素。

### 内部实现

类型的底层数据结构是由**双向链表或压缩列表**实现的:

- 如果列表的元素个数小于 512个，列表每个元素的值都小于 64 字节，Redis 会使用**压缩列表**作为List 类型的底层数据结构;
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构;
- 但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist （二者结合）实现了，替代了双向链表和压缩列表。**

### 常用操作

- lpush：在list左侧插入一个新元素
- rpush：在list右侧插入一个新元素
- lrange：从list中指定一个范围来提取元素
- lpop：移除并返回列表头元素
- rpop：移除并返回列表尾元素

### 应用场景

#### 消息队列

消息队列在存取消息时，必须要满足三个需求，分别是**消息保序、处理重复的消息和保证消息可靠性**。

Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。

1. 如何满足消息保序需求？

   List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。

   List 可以使用 LPUSH+RPOP(或者反过来，RPUSH+LPOP)命令实现消息队列。

   - 生产者使用 LPUSH key value[value...]将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。
   - 消费者使用 RPOP key 依次读取队列的消息，先进先出。

   潜在性能风险点：

   在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP命令(比如使用一个while(1)循环)。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环，

   所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 **CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。**

   为了解决这个问题，Redis提供了 BRPOP 命令。BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。

2. 如何处理重复的消息？

   消费者要实现重复消息的判断，需要2个方面的要求:

   - 每个消息都有一个全局的ID。
   - 消费者要记录已经处理过的消息的ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。

   但是 **List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID**，生成之后我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。

3. 如何保证消息的可靠性？

   当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从List 中读取消息了。

   为了留存消息，List类型提供了 BRPOPLPUSH 命令，这个命令**的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List(可以叫作备份 List)留存**。

   这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。

   ##### 总结

   基于 List 类型的消息队列，满足消息队列的三大需求(消息保序、处理重复的消息和保证消息可靠性)。

   - 消息保序:使用 LPUSH+RPOP;
   - 阻塞读取:使用 BRPOP;
   - 重复消息处理:生产者自行实现全局唯- ID;
   - 消息的可靠性:使用 BRPOPLPUSH

   ##### List做消息队列的缺陷

   **List 不支持多个消费者消费同一条消息**，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了无法被其它消费者再次消费。

   要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 **List 类型并不支持消费组的实现**。

   这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。

## Hash

### 介绍

Hash 是一个键值对(key-value)集合，其中 value 的形式如:value=[{field1,value1},...{fieldN,valueN}]。Hash 特别适合用于存储对象。

### 内部实现

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的:

如果哈希类型元素个数小于 512 个，所有值小于64 字节的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构;

如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的 底层数据结构,

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

### 常用操作

- hset key field value:指定一个 key，设置字段名所对应的值
- hget key field:获取指定 key 和字段对应的值(也可以批量添加)，成功返回操作成功的字段数量
- hmset key field value [field value...]:批量设置某个 key 的字段和对应值，成功返回 OKhmget key filed [filed...]:批量返回某个 key 中指定的字段和其对应值
- hgetall key:用于返回一个 hash 中全部的字段和值
- hexists key field:是否存在某个字段
- hdel key field:删除 key 中的字段，可以删除所有字段，如果删除所有字段，相当于删除了这个 key
- hincrby key filed n:增减操作，hash 中没有类似 decrby 的命令，如果想要减值就直接用负数
- hkeys key:获取所有的字段值
- hvals key:获取所有的值

### 应用场景

#### 缓存对象

Hash 类型的(key，field， value)的结构与对象的(对象id，属性，值)的结构相似，也可以用来存储对象。

在介绍 String 类型的应用场景时有所介绍，String +Json也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢?

一般对象用 String +Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。

#### 购物车

以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素。

涉及的命令如下:

- 添加商品:HSET cart:{用户id}{商品id} 1
- 添加数量:HINCRBY cart:f用户id}{商品id} 1
- 商品总数:HLEN cart:{用户id}
- 删除商品:HDEL cart:{用户id}{商品id}
- 获取购物车所有商品: HGETALL cart:{用户id}

当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。

## Set

### 介绍

Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。

一个集合最多可以存储 2^32-1 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。

Set 类型和 List 类型的区别如下:

- List 可以存储重复元素，Set 只能存储非重复元素;
- List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。

### 内部实现

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构;
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

### 常用操作

- sadd:添加新元素，元素存在则忽略，key不存在则新建
- smembers:列出集合中所有元素
- sismember:判断元素是否在集合中
- scard:返回集合中元素个数
- srem:移除集合中一个或多个元素，如果移除的不存在就不处理
- sinter:对两个集合求交集
- sunion:对两个集合求并集
- sdiff:对两个集合求差集
- setnx:向 Redis 中添加一个 key，只用当 key 不存在的时候才添加并返回 1，存在则不添加返回 0

### 应用场景

集合的主要几个特性，无序、不可重复、支持并交差等操作。

因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。

但是这里有一个潜在的风险。**Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。**

在主从集群中，为了避免主库因为 Set 做聚合计算(交集、差集、并集)时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。

#### 点赞

Set 类型可以保证一个用户只能点一个赞。

key 是文章id，value 是用户id

#### 共同关注

Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。

key 可以是用户id，value 则是已关注的公众号的id。

#### 抽奖活动

存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。

## Zset

### 介绍

Zset 类型(有序集合类型)相比于 Set 类型多了一个排序属性 score(分值)，对于有序集合 ZSet 来说每个存储元素相当于有两个值组成的，一个是有集合的元素值，一个是排序值。

有序集合保留了集合不能有重复成员的特性(分值可以重复)，但不同的是，有序集合中的元素可以排序。

### 内部实现

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的:

如果有序集合的元素个数小于 128个，并且每个元素的值小于 64字节时，Redis 会使用**压缩列表**

作为 Zset 类型的底层数据结构:

如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构;

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

### 常用操作

- zadd:新增一个有序集合，并加入一个元素

- zrange:列出有序集合中的元素

- zrem:从有序集合中删除元素

- zcard:返回有序集合中的数量

  注意：相比于Set类型，Zset类型没有支持差集运算

### 应用场景

Zset 类型(Sorted Set，有序集合)可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。

在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用Sorted Set.

#### 排行榜

有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。

#### 电话、姓名排序

使用有序集合的ZRANGEBYLEX或ZREVRANGEBYLEX可以帮助我们实现电话号码或姓名的排序，我们以(返回指定成员区间内的成员，按 key 正序排列，分数必须相同)为例。ZRANGEBYLEX

**注意:不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。**



